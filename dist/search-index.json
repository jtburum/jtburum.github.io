[{"slug":"2021-elixir-list-to-comma-separated-string","category":"blog","title":"Convert an Elixir List into a comma separated String","description":"Convert an elixir list into a comma separated string","tags":["elixir"],"body":"\nSometimes when working with an Elixir List you may need to utilize that list in a different format, such as a comma separated string. In this event you can reach for the `Enum` module and its `join/2` function, for example:\n\n```\n=> list = [\"snow shoes\", \"biscuits\", \"turtles\"]\n=> string = Enum.join(list, \", \")\n\"snow shoes, biscuits, turtles\"\n```\n"},{"slug":"2021-same-db-table-parent-child-relationship-rails","category":"blog","title":"Same database table parent/child relationship using Rails","description":"rails parent/child relationships same db table","tags":["rails"],"body":"\nWhen developing an application you may come across the need for a context in your application to contain a sub-component like a sub-organization or sub-group. Said differently you may want an organization to be able to create many other organizations or a group to be able to create many other groups. \n\nUsing Rails you can handle this by first creating a migration to add a `parent_id` to the context, in this example Groups.\n\n```ruby\nclass CreateGroups < ActiveRecord::Migration[5.3]\n  def change\n    create_table :groups do |t|\n      t.integer :parent_group_id, index: true\n    end\n  end\nend\n```\n\n```ruby\nclass Group < ApplicationRecord\n  belongs_to :parent_group, class_name: :Group, optional: true\n  has_many :groups, foreign_key: :parent_group_id\nend\n```\n\nFrom there you can establish the relationship in the ActiveRecord model by declaring a Group can belong to another instance of a group through the use of the `parent_group_id` as its connection. Through this connection you can query for a Groups.\n\n```ruby\n=> group = Group.first\n#<Group:0x00000 id: 17, parent_group_id: 1>\n\n# get a groups parent group\n=> group.parent_group\n#<Group:0x00000 id: 1, parent_group_id: nil>\n```\n\nA Group will also have many groups through the `has_many`. Now for an instance of group you can call `.groups` to get all of the child groups associated with it.\n\n```ruby\n=> group = Group.first\n#<Group:0x00000 id: 17, parent_group_id: 1>\n\n# get all child groups for a parent group\n=> group.groups\n[\n  #<Group:0x00000 id: 34, parent_group_id: 17>,\n  #<Group:0x00000 id: 35, parent_group_id: 17>,\n]\n```\n\nSimilar posts:\n- [Redirect to nested resource url in Rails](https://www.devdecks.io/2021-redirect-to-nested-resource-url-rails)\n - [Creating a table with non id primary key in Rails](https://www.devdecks.io/2021-creating-a-table-with-different-primary-key-rails)\n\n"},{"slug":"2021-sidekiq-delete-vs-kill","category":"blog","title":"The difference between Sidekiq's Kill and Delete functions","description":"The difference between Sidekiq's Kill and Delete functions","tags":["rails","sidekiq"],"body":"\nWhen using the Sidekiq UI, there are two buttons for removing jobs from the queue and those are `delete` and `kill`.\n\nThe `delete` option destroys the job entirely with no possibility of replaying in the future.\n\nThe `kill` option moves the job from the queue to the dead tab. From there you can re-enqueue the job anytime you want. This can be useful when testing jobs. If a job or jobs are failing over and over again it can get noisy and difficult to keep track of what is going on so having the `kill` option helps to alleviate this issue.\n\nSimilar post(s):\n[Delete Sidekiq cache key](https://www.devdecks.io/2021-delete-sidekiq-cache-key)"}]